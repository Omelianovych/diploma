// go:build ignore

#include "headers/vmlinux.h"
#include <bpf/bpf_core_read.h>
#include <bpf/bpf_helpers.h>

#define TASK_COMM_LEN 16
#define FILE_NAME_LEN 128
// Максимум 6 аргументов
#define MAX_ARGS_COUNT 6
// Длина одного аргумента
#define ARG_SIZE 42

struct common_event {
  u64 cgroup_id;
  u32 pid;
  u32 ppid;
  u32 uid;
  u32 gid;
  char comm[TASK_COMM_LEN];
  char pcomm[TASK_COMM_LEN];
};

struct openat_event {
  struct common_event common;
  int flags;
  int dfd;
  int ret;
  char filename[FILE_NAME_LEN];
};

// Изменили структуру: теперь args это массив строк, а не одна строка
struct execve_event {
  struct common_event common;
  int ret;
  char filename[FILE_NAME_LEN];
  char args[MAX_ARGS_COUNT][ARG_SIZE];
};

struct openat_args_t {
  int dfd;
  int flags;
  char filename[FILE_NAME_LEN];
};

// Промежуточное хранилище тоже обновляем
struct execve_args_t {
  char filename[FILE_NAME_LEN];
  char args[MAX_ARGS_COUNT][ARG_SIZE];
};

// --- MAPS ---

struct {
  __uint(type, BPF_MAP_TYPE_RINGBUF);
  __uint(max_entries, 1 << 24);
} openat_events SEC(".maps");

struct {
  __uint(type, BPF_MAP_TYPE_HASH);
  __uint(max_entries, 10240);
  __type(key, u32);
  __type(value, struct openat_args_t);
} openat_tmp_storage SEC(".maps");

struct {
  __uint(type, BPF_MAP_TYPE_RINGBUF);
  __uint(max_entries, 1 << 24);
} execve_events SEC(".maps");

struct {
  __uint(type, BPF_MAP_TYPE_HASH);
  __uint(max_entries, 10240);
  __type(key, u32);
  __type(value, struct execve_args_t);
} execve_tmp_storage SEC(".maps");

struct {
  __uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);
  __uint(max_entries, 1);
  __type(key, u32);
  __type(value, struct execve_args_t);
} execve_heap SEC(".maps");

// --- HELPERS ---

static __always_inline void fill_common_event(struct common_event *e) {
  u64 id = bpf_get_current_pid_tgid();
  e->pid = id >> 32;
  e->cgroup_id = bpf_get_current_cgroup_id();

  u64 uid_gid = bpf_get_current_uid_gid();
  e->uid = (u32)uid_gid;
  e->gid = (u32)(uid_gid >> 32);

  bpf_get_current_comm(&e->comm, sizeof(e->comm));

  struct task_struct *task = (struct task_struct *)bpf_get_current_task();
  struct task_struct *parent;
  bpf_probe_read_kernel(&parent, sizeof(parent), &task->real_parent);
  bpf_probe_read_kernel(&e->ppid, sizeof(e->ppid), &parent->tgid);
  bpf_probe_read_kernel(&e->pcomm, sizeof(e->pcomm), &parent->comm);
}

// --- OPENAT ---

SEC("tracepoint/syscalls/sys_enter_openat")
int trace_enter_openat(struct trace_event_raw_sys_enter *ctx) {
  u64 id = bpf_get_current_pid_tgid();
  u32 tid = id;

  struct openat_args_t args = {};
  args.dfd = (int)ctx->args[0];
  args.flags = (int)ctx->args[2];
  bpf_probe_read_user_str(&args.filename, sizeof(args.filename),
                          (char *)ctx->args[1]);

  bpf_map_update_elem(&openat_tmp_storage, &tid, &args, BPF_ANY);
  return 0;
}

SEC("tracepoint/syscalls/sys_exit_openat")
int trace_exit_openat(struct trace_event_raw_sys_exit *ctx) {
  u64 id = bpf_get_current_pid_tgid();
  u32 tid = id;

  struct openat_args_t *saved_args =
      bpf_map_lookup_elem(&openat_tmp_storage, &tid);
  if (!saved_args)
    return 0;

  struct openat_event *e = bpf_ringbuf_reserve(&openat_events, sizeof(*e), 0);
  if (!e) {
    bpf_map_delete_elem(&openat_tmp_storage, &tid);
    return 0;
  }

  fill_common_event(&e->common);
  e->dfd = saved_args->dfd;
  e->flags = saved_args->flags;
  e->ret = (int)ctx->ret;
  bpf_probe_read_kernel(&e->filename, sizeof(e->filename),
                        saved_args->filename);

  bpf_ringbuf_submit(e, 0);
  bpf_map_delete_elem(&openat_tmp_storage, &tid);
  return 0;
}

// --- EXECVE ---
SEC("tracepoint/syscalls/sys_enter_execve")
int trace_enter_execve(struct trace_event_raw_sys_enter *ctx) {
  u64 id = bpf_get_current_pid_tgid();
  u32 tid = id;

  u32 zero = 0;
  struct execve_args_t *args = bpf_map_lookup_elem(&execve_heap, &zero);
  if (!args)
    return 0;

  // Очистка памяти
  __builtin_memset(args, 0, sizeof(*args));

  // 1. Имя файла
  bpf_probe_read_user_str(&args->filename, sizeof(args->filename),
                          (char *)ctx->args[0]);

  // 2. Аргументы
  const char **argv = (const char **)ctx->args[1];

  if (argv) {
// Loop unrolling is mandatory for verifier to track index bounds
#pragma unroll
    for (int i = 0; i < MAX_ARGS_COUNT; i++) {
      const char *argp;

      // Читаем указатель на строку
      if (bpf_probe_read_user(&argp, sizeof(argp), &argv[i]) < 0 || !argp) {
        // Если аргументов меньше 6, мы тут остановимся
        break;
      }

      // Читаем саму строку прямо в ячейку массива args[i]
      // Никаких offset, никакой сложной арифметики. Верификатор счастлив.
      bpf_probe_read_user_str(&args->args[i], ARG_SIZE, argp);
    }
  }

  bpf_map_update_elem(&execve_tmp_storage, &tid, args, BPF_ANY);
  return 0;
}

SEC("tracepoint/syscalls/sys_exit_execve")
int trace_exit_execve(struct trace_event_raw_sys_exit *ctx) {
  u64 id = bpf_get_current_pid_tgid();
  u32 tid = id;

  struct execve_args_t *saved_args =
      bpf_map_lookup_elem(&execve_tmp_storage, &tid);
  if (!saved_args)
    return 0;

  struct execve_event *e = bpf_ringbuf_reserve(&execve_events, sizeof(*e), 0);
  if (!e) {
    bpf_map_delete_elem(&execve_tmp_storage, &tid);
    return 0;
  }

  fill_common_event(&e->common);
  e->ret = (int)ctx->ret;

  // Копируем имя файла
  bpf_probe_read_kernel(&e->filename, sizeof(e->filename),
                        saved_args->filename);

  // Копируем весь массив аргументов разом (структуры идентичны)
  bpf_probe_read_kernel(&e->args, sizeof(e->args), saved_args->args);

  bpf_ringbuf_submit(e, 0);
  bpf_map_delete_elem(&execve_tmp_storage, &tid);
  return 0;
}

char LICENSE[] SEC("license") = "GPL";
