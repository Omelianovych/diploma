// go:build ignore

#include "headers/vmlinux.h"
#include <bpf/bpf_core_read.h>
#include <bpf/bpf_helpers.h>

#define TASK_COMM_LEN 16
#define FILE_NAME_LEN 128
// Максимум 16 аргументов (безопасный лимит для верификатора)
#define MAX_ARGS_COUNT 24
#define ARG_SIZE 64
#define AF_INET 2

struct common_event {
  u64 cgroup_id;
  u32 pid;
  u32 ppid;
  u32 uid;
  u32 gid;
  char comm[TASK_COMM_LEN];
  char pcomm[TASK_COMM_LEN];
};

struct openat_event {
  struct common_event common;
  int flags;
  int dfd;
  int ret;
  char filename[FILE_NAME_LEN];
};

// Изменили структуру: используем argv и envp
struct execve_event {
  struct common_event common;
  int ret;
  char filename[FILE_NAME_LEN];
  char argv[MAX_ARGS_COUNT][ARG_SIZE]; // Было args
  char envp[MAX_ARGS_COUNT][ARG_SIZE]; // Было envs
};

struct openat_args_t {
  int dfd;
  int flags;
  char filename[FILE_NAME_LEN];
};

// Промежуточное хранилище тоже обновляем
struct execve_args_t {
  char filename[FILE_NAME_LEN];
  char argv[MAX_ARGS_COUNT][ARG_SIZE]; // Было args
  char envp[MAX_ARGS_COUNT][ARG_SIZE]; // Было envs
};

struct connect_event {
  struct common_event common;
  int ret;
  int fd;
  u32 ip;   // IPv4 адрес (в сетевом порядке или хостовом, разберемся в Go)
  u16 port; // Порт
};

struct connect_args_t {
  int fd;
  u32 ip;
  u16 port;
};

struct accept_event {
  struct common_event common;
  int ret;  // Возвращенный FD
  u32 ip;   // Remote IP
  u16 port; // Remote Port
};

struct accept_args_t {
  u64 addr; // Указатель на структуру в user-space
};

struct ptrace_event {
  struct common_event common;
  int ret;
  long request;   // PTRACE_ATTACH, PTRACE_PEEKTEXT и т.д.
  int target_pid; // PID процесса, над которым совершается действие
  u64 addr;
};

struct ptrace_args_t {
  long request;
  int target_pid;
  u64 addr;
};
// --- MAPS ---

struct {
  __uint(type, BPF_MAP_TYPE_RINGBUF);
  __uint(max_entries, 1 << 24);
} openat_events SEC(".maps");

struct {
  __uint(type, BPF_MAP_TYPE_HASH);
  __uint(max_entries, 10240);
  __type(key, u32);
  __type(value, struct openat_args_t);
} openat_tmp_storage SEC(".maps");

struct {
  __uint(type, BPF_MAP_TYPE_RINGBUF);
  __uint(max_entries, 1 << 24);
} execve_events SEC(".maps");

struct {
  __uint(type, BPF_MAP_TYPE_HASH);
  __uint(max_entries, 10240);
  __type(key, u32);
  __type(value, struct execve_args_t);
} execve_tmp_storage SEC(".maps");

struct {
  __uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);
  __uint(max_entries, 1);
  __type(key, u32);
  __type(value, struct execve_args_t);
} execve_heap SEC(".maps");

struct {
  __uint(type, BPF_MAP_TYPE_RINGBUF);
  __uint(max_entries, 1 << 24);
} connect_events SEC(".maps");

struct {
  __uint(type, BPF_MAP_TYPE_HASH);
  __uint(max_entries, 10240);
  __type(key, u32);
  __type(value, struct connect_args_t);
} connect_tmp_storage SEC(".maps");

struct {
  __uint(type, BPF_MAP_TYPE_RINGBUF);
  __uint(max_entries, 1 << 24);
} accept_events SEC(".maps");

struct {
  __uint(type, BPF_MAP_TYPE_HASH);
  __uint(max_entries, 10240);
  __type(key, u32);
  __type(value, struct accept_args_t);
} accept_tmp_storage SEC(".maps");

struct {
  __uint(type, BPF_MAP_TYPE_RINGBUF);
  __uint(max_entries, 1 << 24);
} ptrace_events SEC(".maps");

struct {
  __uint(type, BPF_MAP_TYPE_HASH);
  __uint(max_entries, 10240);
  __type(key, u32);
  __type(value, struct ptrace_args_t);
} ptrace_tmp_storage SEC(".maps");
// --- HELPERS ---

static __always_inline void fill_common_event(struct common_event *e) {
  u64 id = bpf_get_current_pid_tgid();
  e->pid = id >> 32;
  e->cgroup_id = bpf_get_current_cgroup_id();

  u64 uid_gid = bpf_get_current_uid_gid();
  e->uid = (u32)uid_gid;
  e->gid = (u32)(uid_gid >> 32);

  bpf_get_current_comm(&e->comm, sizeof(e->comm));

  struct task_struct *task = (struct task_struct *)bpf_get_current_task();
  struct task_struct *parent;
  bpf_probe_read_kernel(&parent, sizeof(parent), &task->real_parent);
  bpf_probe_read_kernel(&e->ppid, sizeof(e->ppid), &parent->tgid);
  bpf_probe_read_kernel(&e->pcomm, sizeof(e->pcomm), &parent->comm);
}

// --- OPENAT ---

SEC("tracepoint/syscalls/sys_enter_openat")
int trace_enter_openat(struct trace_event_raw_sys_enter *ctx) {
  u64 id = bpf_get_current_pid_tgid();
  u32 tid = id;

  struct openat_args_t args = {};
  args.dfd = (int)ctx->args[0];
  args.flags = (int)ctx->args[2];
  bpf_probe_read_user_str(&args.filename, sizeof(args.filename),
                          (char *)ctx->args[1]);

  bpf_map_update_elem(&openat_tmp_storage, &tid, &args, BPF_ANY);
  return 0;
}

SEC("tracepoint/syscalls/sys_exit_openat")
int trace_exit_openat(struct trace_event_raw_sys_exit *ctx) {
  u64 id = bpf_get_current_pid_tgid();
  u32 tid = id;

  struct openat_args_t *saved_args =
      bpf_map_lookup_elem(&openat_tmp_storage, &tid);
  if (!saved_args)
    return 0;

  struct openat_event *e = bpf_ringbuf_reserve(&openat_events, sizeof(*e), 0);
  if (!e) {
    bpf_map_delete_elem(&openat_tmp_storage, &tid);
    return 0;
  }

  fill_common_event(&e->common);
  e->dfd = saved_args->dfd;
  e->flags = saved_args->flags;
  e->ret = (int)ctx->ret;
  bpf_probe_read_kernel(&e->filename, sizeof(e->filename),
                        saved_args->filename);

  bpf_ringbuf_submit(e, 0);
  bpf_map_delete_elem(&openat_tmp_storage, &tid);
  return 0;
}

// --- EXECVE ---
SEC("tracepoint/syscalls/sys_enter_execve")
int trace_enter_execve(struct trace_event_raw_sys_enter *ctx) {
  u64 id = bpf_get_current_pid_tgid();
  u32 tid = id;

  u32 zero = 0;
  struct execve_args_t *args = bpf_map_lookup_elem(&execve_heap, &zero);
  if (!args)
    return 0;

  // Очистка памяти вручную (первые байты)
  args->filename[0] = '\0';

#pragma unroll
  for (int i = 0; i < MAX_ARGS_COUNT; i++) {
    args->argv[i][0] = '\0'; // Было args
    args->envp[i][0] = '\0'; // Было envs
  }

  // 1. Имя файла
  bpf_probe_read_user_str(&args->filename, sizeof(args->filename),
                          (char *)ctx->args[0]);

  // 2. Аргументы (argv)
  const char **argv = (const char **)ctx->args[1];

  if (argv) {
#pragma unroll
    for (int i = 0; i < MAX_ARGS_COUNT; i++) {
      const char *argp;
      if (bpf_probe_read_user(&argp, sizeof(argp), &argv[i]) < 0 || !argp) {
        break;
      }
      // Пишем в argv
      bpf_probe_read_user_str(&args->argv[i], ARG_SIZE, argp);
    }
  }

  // 3. Окружение (envp)
  const char **envp = (const char **)ctx->args[2];
  if (envp) {
#pragma unroll
    for (int i = 0; i < MAX_ARGS_COUNT; i++) {
      const char *env_ptr;
      if (bpf_probe_read_user(&env_ptr, sizeof(env_ptr), &envp[i]) < 0 ||
          !env_ptr)
        break;
      // Пишем в envp
      bpf_probe_read_user_str(&args->envp[i], ARG_SIZE, env_ptr);
    }
  }
  bpf_map_update_elem(&execve_tmp_storage, &tid, args, BPF_ANY);
  return 0;
}

SEC("tracepoint/syscalls/sys_exit_execve")
int trace_exit_execve(struct trace_event_raw_sys_exit *ctx) {
  u64 id = bpf_get_current_pid_tgid();
  u32 tid = id;

  struct execve_args_t *saved_args =
      bpf_map_lookup_elem(&execve_tmp_storage, &tid);
  if (!saved_args)
    return 0;

  struct execve_event *e = bpf_ringbuf_reserve(&execve_events, sizeof(*e), 0);
  if (!e) {
    bpf_map_delete_elem(&execve_tmp_storage, &tid);
    return 0;
  }

  fill_common_event(&e->common);

  // Кастим контекст для верности (хотя оффсеты ret обычно совпадают)
  struct trace_event_raw_sys_exit *exit_ctx =
      (struct trace_event_raw_sys_exit *)ctx;
  e->ret = (int)exit_ctx->ret;

  bpf_probe_read_kernel(&e->filename, sizeof(e->filename),
                        saved_args->filename);

  // Копируем argv
  bpf_probe_read_kernel(&e->argv, sizeof(e->argv), saved_args->argv);

  // Копируем envp
  bpf_probe_read_kernel(&e->envp, sizeof(e->envp), saved_args->envp);

  bpf_ringbuf_submit(e, 0);
  bpf_map_delete_elem(&execve_tmp_storage, &tid);
  return 0;
}

// ================= CONNECT PROBES (NEW) =================

SEC("tracepoint/syscalls/sys_enter_connect")
int trace_enter_connect(struct trace_event_raw_sys_enter *ctx) {
  u64 id = bpf_get_current_pid_tgid();
  u32 tid = id;

  // Аргументы connect: int sockfd, const struct sockaddr *addr, socklen_t
  // addrlen
  struct sockaddr *useraddr = (struct sockaddr *)ctx->args[1];

  // Считываем семейство адресов (AF_INET, AF_INET6)
  short family;
  if (bpf_probe_read_user(&family, sizeof(family), &useraddr->sa_family) < 0) {
    return 0;
  }

  // Пока обрабатываем только IPv4 (AF_INET = 2)
  if (family != AF_INET) {
    return 0;
  }

  // Кастим к sockaddr_in чтобы достать IP и порт
  struct sockaddr_in *addr_in = (struct sockaddr_in *)useraddr;
  struct connect_args_t args = {};

  args.fd = (int)ctx->args[0];

  // Читаем IP и Port
  bpf_probe_read_user(&args.ip, sizeof(args.ip), &addr_in->sin_addr.s_addr);
  bpf_probe_read_user(&args.port, sizeof(args.port), &addr_in->sin_port);

  bpf_map_update_elem(&connect_tmp_storage, &tid, &args, BPF_ANY);
  return 0;
}

SEC("tracepoint/syscalls/sys_exit_connect")
int trace_exit_connect(struct trace_event_raw_sys_exit *ctx) {
  u64 id = bpf_get_current_pid_tgid();
  u32 tid = id;

  struct connect_args_t *saved_args =
      bpf_map_lookup_elem(&connect_tmp_storage, &tid);
  if (!saved_args)
    return 0;

  struct connect_event *e = bpf_ringbuf_reserve(&connect_events, sizeof(*e), 0);
  if (!e) {
    bpf_map_delete_elem(&connect_tmp_storage, &tid);
    return 0;
  }

  fill_common_event(&e->common);
  struct trace_event_raw_sys_exit *exit_ctx =
      (struct trace_event_raw_sys_exit *)ctx;
  e->ret = (int)exit_ctx->ret;

  e->fd = saved_args->fd;
  e->ip = saved_args->ip;
  e->port = saved_args->port;

  bpf_ringbuf_submit(e, 0);
  bpf_map_delete_elem(&connect_tmp_storage, &tid);
  return 0;
}

// --- ACCEPT ---
SEC("tracepoint/syscalls/sys_enter_accept4")
int trace_enter_accept4(struct trace_event_raw_sys_enter *ctx) {
  u64 id = bpf_get_current_pid_tgid();
  u32 tid = id;

  struct accept_args_t args = {};
  // 2-й аргумент accept4: struct sockaddr *upeer_sockaddr
  // ИСПРАВЛЕНИЕ: кастим к u64
  args.addr = (u64)ctx->args[1];

  bpf_map_update_elem(&accept_tmp_storage, &tid, &args, BPF_ANY);
  return 0;
}

SEC("tracepoint/syscalls/sys_exit_accept4")
int trace_exit_accept4(struct trace_event_raw_sys_exit *ctx) {
  u64 id = bpf_get_current_pid_tgid();
  u32 tid = id;

  struct accept_args_t *saved_args =
      bpf_map_lookup_elem(&accept_tmp_storage, &tid);
  if (!saved_args)
    return 0;

  // Если accept вернул ошибку (<0), значит соединения нет
  if (ctx->ret < 0) {
    bpf_map_delete_elem(&accept_tmp_storage, &tid);
    return 0;
  }

  struct accept_event *e = bpf_ringbuf_reserve(&accept_events, sizeof(*e), 0);
  if (!e) {
    bpf_map_delete_elem(&accept_tmp_storage, &tid);
    return 0;
  }

  fill_common_event(&e->common);
  e->ret = (int)ctx->ret;

  // Читаем IP/Port, которые ядро записало в память пользователя
  if (saved_args->addr) {
    // ИСПРАВЛЕНИЕ: кастим u64 обратно к указателю
    struct sockaddr *sa = (struct sockaddr *)saved_args->addr;
    short family;
    bpf_probe_read_user(&family, sizeof(family), &sa->sa_family);

    if (family == AF_INET) {
      struct sockaddr_in *sin = (struct sockaddr_in *)sa;
      bpf_probe_read_user(&e->ip, sizeof(e->ip), &sin->sin_addr.s_addr);
      bpf_probe_read_user(&e->port, sizeof(e->port), &sin->sin_port);
    }
  }

  bpf_ringbuf_submit(e, 0);
  bpf_map_delete_elem(&accept_tmp_storage, &tid);
  return 0;
}

// --- PTRACE (NEW) ---

SEC("tracepoint/syscalls/sys_enter_ptrace")
int trace_enter_ptrace(struct trace_event_raw_sys_enter *ctx) {
  u64 id = bpf_get_current_pid_tgid();
  u32 tid = id;

  struct ptrace_args_t args = {};
  // long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void
  // *data);
  args.request = (long)ctx->args[0];
  args.target_pid = (int)ctx->args[1];
  args.addr = (u64)ctx->args[2];

  bpf_map_update_elem(&ptrace_tmp_storage, &tid, &args, BPF_ANY);
  return 0;
}

SEC("tracepoint/syscalls/sys_exit_ptrace")
int trace_exit_ptrace(struct trace_event_raw_sys_exit *ctx) {
  u64 id = bpf_get_current_pid_tgid();
  u32 tid = id;

  struct ptrace_args_t *saved_args =
      bpf_map_lookup_elem(&ptrace_tmp_storage, &tid);
  if (!saved_args)
    return 0;

  struct ptrace_event *e = bpf_ringbuf_reserve(&ptrace_events, sizeof(*e), 0);
  if (!e) {
    bpf_map_delete_elem(&ptrace_tmp_storage, &tid);
    return 0;
  }

  fill_common_event(&e->common);
  e->ret = (int)ctx->ret;
  e->request = saved_args->request;
  e->target_pid = saved_args->target_pid;
  e->addr = saved_args->addr;

  bpf_ringbuf_submit(e, 0);
  bpf_map_delete_elem(&ptrace_tmp_storage, &tid);
  return 0;
}

char LICENSE[] SEC("license") = "GPL";
