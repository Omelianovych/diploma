// go:build ignore

#include "headers/vmlinux.h"
#include <bpf/bpf_core_read.h>
#include <bpf/bpf_helpers.h>

#define TASK_COMM_LEN 16
#define FILE_NAME_LEN 128
#define ARGS_LEN 256
// ARGS_LEN должен быть степенью двойки для маски (256 = 0xFF + 1)
#define ARGS_MASK 255
#define MAX_ARGS_COUNT 6

struct common_event {
  u64 cgroup_id;
  u32 pid;
  u32 ppid;
  u32 uid;
  u32 gid;
  char comm[TASK_COMM_LEN];
  char pcomm[TASK_COMM_LEN];
};

struct openat_event {
  struct common_event common;
  int flags;
  int dfd;
  int ret;
  char filename[FILE_NAME_LEN];
};

struct execve_event {
  struct common_event common;
  int ret;
  char filename[FILE_NAME_LEN];
  char args[ARGS_LEN];
};

struct openat_args_t {
  int dfd;
  int flags;
  char filename[FILE_NAME_LEN];
};

struct execve_args_t {
  char filename[FILE_NAME_LEN];
  char args[ARGS_LEN];
};

// --- MAPS ---

struct {
  __uint(type, BPF_MAP_TYPE_RINGBUF);
  __uint(max_entries, 1 << 24);
} openat_events SEC(".maps");

struct {
  __uint(type, BPF_MAP_TYPE_HASH);
  __uint(max_entries, 10240);
  __type(key, u32);
  __type(value, struct openat_args_t);
} openat_tmp_storage SEC(".maps");

struct {
  __uint(type, BPF_MAP_TYPE_RINGBUF);
  __uint(max_entries, 1 << 24);
} execve_events SEC(".maps");

struct {
  __uint(type, BPF_MAP_TYPE_HASH);
  __uint(max_entries, 10240);
  __type(key, u32);
  __type(value, struct execve_args_t);
} execve_tmp_storage SEC(".maps");

struct {
  __uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);
  __uint(max_entries, 1);
  __type(key, u32);
  __type(value, struct execve_args_t);
} execve_heap SEC(".maps");

// --- HELPERS ---

static __always_inline void fill_common_event(struct common_event *e) {
  u64 id = bpf_get_current_pid_tgid();
  e->pid = id >> 32;
  e->cgroup_id = bpf_get_current_cgroup_id();

  u64 uid_gid = bpf_get_current_uid_gid();
  e->uid = (u32)uid_gid;
  e->gid = (u32)(uid_gid >> 32);

  bpf_get_current_comm(&e->comm, sizeof(e->comm));

  struct task_struct *task = (struct task_struct *)bpf_get_current_task();
  struct task_struct *parent;
  bpf_probe_read_kernel(&parent, sizeof(parent), &task->real_parent);
  bpf_probe_read_kernel(&e->ppid, sizeof(e->ppid), &parent->tgid);
  bpf_probe_read_kernel(&e->pcomm, sizeof(e->pcomm), &parent->comm);
}

// --- OPENAT ---

SEC("tracepoint/syscalls/sys_enter_openat")
int trace_enter_openat(struct trace_event_raw_sys_enter *ctx) {
  u64 id = bpf_get_current_pid_tgid();
  u32 tid = id;

  struct openat_args_t args = {};
  args.dfd = (int)ctx->args[0];
  args.flags = (int)ctx->args[2];
  bpf_probe_read_user_str(&args.filename, sizeof(args.filename),
                          (char *)ctx->args[1]);

  bpf_map_update_elem(&openat_tmp_storage, &tid, &args, BPF_ANY);
  return 0;
}

SEC("tracepoint/syscalls/sys_exit_openat")
int trace_exit_openat(struct trace_event_raw_sys_exit *ctx) {
  u64 id = bpf_get_current_pid_tgid();
  u32 tid = id;

  struct openat_args_t *saved_args =
      bpf_map_lookup_elem(&openat_tmp_storage, &tid);
  if (!saved_args)
    return 0;

  struct openat_event *e = bpf_ringbuf_reserve(&openat_events, sizeof(*e), 0);
  if (!e) {
    bpf_map_delete_elem(&openat_tmp_storage, &tid);
    return 0;
  }

  fill_common_event(&e->common);
  e->dfd = saved_args->dfd;
  e->flags = saved_args->flags;
  e->ret = (int)ctx->ret;
  bpf_probe_read_kernel(&e->filename, sizeof(e->filename),
                        saved_args->filename);

  bpf_ringbuf_submit(e, 0);
  bpf_map_delete_elem(&openat_tmp_storage, &tid);
  return 0;
}

// --- EXECVE ---

SEC("tracepoint/syscalls/sys_enter_execve")
int trace_enter_execve(struct trace_event_raw_sys_enter *ctx) {
  u64 id = bpf_get_current_pid_tgid();
  u32 tid = id;

  u32 zero = 0;
  struct execve_args_t *args = bpf_map_lookup_elem(&execve_heap, &zero);
  if (!args)
    return 0;

  // memset заменен на явное зануление первого байта для экономии инструкций,
  // но для чистоты лучше memset, если компилятор позволяет.
  __builtin_memset(args, 0, sizeof(*args));

  bpf_probe_read_user_str(&args->filename, sizeof(args->filename),
                          (char *)ctx->args[0]);

  const char **argv = (const char **)(ctx->args[1]);
  if (argv) {
    // Используем u32 для индексации
    u32 offset = 0;

#pragma unroll
    for (int i = 0; i < MAX_ARGS_COUNT; i++) {
      const char *arg_ptr;
      bpf_probe_read_user(&arg_ptr, sizeof(arg_ptr), &argv[i]);
      if (!arg_ptr)
        break;

      // 1. Логическая проверка выхода за границы
      if (offset >= ARGS_LEN)
        break;

      // 2. !!! MAGIC TRICK !!!
      // Накладываем маску. Теперь верификатор ЗНАЕТ, что safe_offset <= 255.
      u32 safe_offset = offset & ARGS_MASK;

      // 3. Вычисляем оставшееся место
      // Здесь верификатор может параноить на вычитании, поэтому используем
      // маску снова Но проще сказать ему читать ограниченный кусок.

      // Пишем по безопасному смещению
      // ARGS_LEN (256) - safe_offset всегда >= 1
      int ret = bpf_probe_read_user_str(&args->args[safe_offset],
                                        ARGS_LEN - safe_offset, arg_ptr);

      if (ret > 0) {
        offset += ret;
        // Искусственно ограничиваем offset, чтобы верификатор не думал, что он
        // растет бесконечно
        if (offset >= ARGS_LEN) {
          break;
        }
      } else {
        break;
      }
    }
  }

  bpf_map_update_elem(&execve_tmp_storage, &tid, args, BPF_ANY);
  return 0;
}

SEC("tracepoint/syscalls/sys_exit_execve")
int trace_exit_execve(struct trace_event_raw_sys_exit *ctx) {
  u64 id = bpf_get_current_pid_tgid();
  u32 tid = id;

  struct execve_args_t *saved_args =
      bpf_map_lookup_elem(&execve_tmp_storage, &tid);
  if (!saved_args)
    return 0;

  struct execve_event *e = bpf_ringbuf_reserve(&execve_events, sizeof(*e), 0);
  if (!e) {
    bpf_map_delete_elem(&execve_tmp_storage, &tid);
    return 0;
  }

  fill_common_event(&e->common);
  e->ret = (int)ctx->ret;
  bpf_probe_read_kernel(&e->filename, sizeof(e->filename),
                        saved_args->filename);
  bpf_probe_read_kernel(&e->args, sizeof(e->args), saved_args->args);

  bpf_ringbuf_submit(e, 0);
  bpf_map_delete_elem(&execve_tmp_storage, &tid);
  return 0;
}

char LICENSE[] SEC("license") = "GPL";
