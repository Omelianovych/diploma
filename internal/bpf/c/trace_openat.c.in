// go:build ignore

#include "headers/vmlinux.h"
#include <bpf/bpf_helpers.h>

/*
 * 1. Итоговая структура события (Event)
 * Отправляется в userspace через RingBuffer.
 * ОБЯЗАТЕЛЬНО: обновите Go-структуру, чтобы она совпадала с этой!
 */
struct event {
  u64 cgroup_id;      // ID контейнера (cgroup v2)
  u32 pid;            // Process ID
  u32 uid;            // User ID
  u32 gid;            // Group ID
  int flags;          // Флаги (O_RDWR, O_CREAT...)
  int dfd;            // Directory FD (важно для относительных путей)
  int ret;            // Результат выполнения (FD или код ошибки -ENOENT)
  char comm[16];      // Имя процесса
  char filename[256]; // Имя файла
};

/*
 * 2. Временная структура (Storage)
 * Используется для хранения аргументов между sys_enter и sys_exit.
 */
struct args_t {
  int dfd;
  int flags;
  char filename[256];
};

/*
 * 3. Карты (Maps)
 */

// Основной канал передачи данных в Go
struct {
  __uint(type, BPF_MAP_TYPE_RINGBUF);
  __uint(max_entries, 1 << 24); // 16MB
} events SEC(".maps");

// Временное хранилище: PID -> Аргументы
struct {
  __uint(type, BPF_MAP_TYPE_HASH);
  __uint(max_entries, 10240); // Поддержка до 10k одновременных сисколлов
  __type(key, u32);           // PID
  __type(value, struct args_t);
} tmp_storage SEC(".maps");

/*
 * 4. Точка ВХОДА (sys_enter)
 * Здесь мы только захватываем аргументы, так как filename доступен только тут.
 */
SEC("tracepoint/syscalls/sys_enter_openat")
int tracepoint__syscalls__sys_enter_openat(
    struct trace_event_raw_sys_enter *ctx) {
  u64 id = bpf_get_current_pid_tgid();
  u32 pid = id >> 32;

  struct args_t args = {};

  // 1. Сохраняем аргументы сисколла
  // openat(int dfd, const char *filename, int flags, umode_t mode)
  // args[0] = dfd
  // args[1] = filename ptr
  // args[2] = flags
  args.dfd = (int)ctx->args[0];
  args.flags = (int)ctx->args[2];

  // Читаем имя файла из памяти пользователя
  bpf_probe_read_user_str(&args.filename, sizeof(args.filename),
                          (char *)ctx->args[1]);

  // 2. Кладем во временную карту по PID
  bpf_map_update_elem(&tmp_storage, &pid, &args, BPF_ANY);

  return 0;
}

/*
 * 5. Точка ВЫХОДА (sys_exit)
 * Здесь мы знаем результат (ret), собираем всё вместе и отправляем.
 */
SEC("tracepoint/syscalls/sys_exit_openat")
int tracepoint__syscalls__sys_exit_openat(
    struct trace_event_raw_sys_exit *ctx) {
  u64 id = bpf_get_current_pid_tgid();
  u32 pid = id >> 32;

  // 1. Ищем сохраненные аргументы
  struct args_t *saved_args;
  saved_args = bpf_map_lookup_elem(&tmp_storage, &pid);

  if (!saved_args) {
    return 0; // Мы пропустили вход или это не наш процесс
  }

  // 2. Резервируем место в RingBuffer
  struct event *e;
  e = bpf_ringbuf_reserve(&events, sizeof(*e), 0);
  if (!e) {
    bpf_map_delete_elem(&tmp_storage, &pid); // Не забываем чистить карту
    return 0;
  }

  // 3. Заполняем контекстные данные (Контейнеры, Юзеры)
  e->pid = pid;
  e->cgroup_id = bpf_get_current_cgroup_id();

  u64 uid_gid = bpf_get_current_uid_gid();
  e->uid = (u32)uid_gid;
  e->gid = (u32)(uid_gid >> 32);

  bpf_get_current_comm(&e->comm, sizeof(e->comm));

  // 4. Заполняем данные сисколла из временного хранилища
  e->dfd = saved_args->dfd;
  e->flags = saved_args->flags;
  // Копируем имя файла (используем __builtin_memcpy или цикл, но для простоты
  // bpf_probe_read_kernel) Так как saved_args находится в памяти BPF,
  // используем простое присваивание для массивов фиксированной длины или helper
  // для копирования памяти. В старых ядрах нужно использовать bpf_probe_read, в
  // новых __builtin_memcpy работает. Для надежности используем helper чтения:
  bpf_probe_read_kernel(&e->filename, sizeof(e->filename),
                        saved_args->filename);

  // 5. Самое главное: Результат выполнения
  e->ret = (int)ctx->ret;

  // 6. Отправляем в Go
  bpf_ringbuf_submit(e, 0);

  // 7. Очищаем временное хранилище
  bpf_map_delete_elem(&tmp_storage, &pid);

  return 0;
}

char LICENSE[] SEC("license") = "GPL";
