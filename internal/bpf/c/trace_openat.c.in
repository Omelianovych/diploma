// go:build ignore

#include "headers/vmlinux.h"
#include <bpf/bpf_helpers.h>

/*
 * 1. Итоговая структура события (Event)
 */
struct event {
  u64 cgroup_id;
  u32 pid;
  u32 ppid; // Parent PID
  u32 uid;
  u32 gid;
  int flags;
  int dfd;
  int ret;
  char comm[16];
  char pcomm[16];
  char filename[256];
};

/*
 * 2. Временная структура
 */
struct args_t {
  int dfd;
  int flags;
  char filename[256];
};

/*
 * 3. Карты
 */
struct {
  __uint(type, BPF_MAP_TYPE_RINGBUF);
  __uint(max_entries, 1 << 24);
} events SEC(".maps");

struct {
  __uint(type, BPF_MAP_TYPE_HASH);
  __uint(max_entries, 10240);
  __type(key, u32);
  __type(value, struct args_t);
} tmp_storage SEC(".maps");

/*
 * 4. ВХОД (без изменений)
 */
SEC("tracepoint/syscalls/sys_enter_openat")
int tracepoint__syscalls__sys_enter_openat(
    struct trace_event_raw_sys_enter *ctx) {
  u64 id = bpf_get_current_pid_tgid();
  u32 tid = id;

  struct args_t args = {};
  args.dfd = (int)ctx->args[0];
  args.flags = (int)ctx->args[2];
  bpf_probe_read_user_str(&args.filename, sizeof(args.filename),
                          (char *)ctx->args[1]);

  bpf_map_update_elem(&tmp_storage, &tid, &args, BPF_ANY);
  return 0;
}

/*
 * 5. ВЫХОД (Исправленный PPID)
 */
SEC("tracepoint/syscalls/sys_exit_openat")
int tracepoint__syscalls__sys_exit_openat(
    struct trace_event_raw_sys_exit *ctx) {
  u64 id = bpf_get_current_pid_tgid();
  u32 tid = id;
  u32 pid = id >> 32;

  struct args_t *saved_args;
  saved_args = bpf_map_lookup_elem(&tmp_storage, &tid);

  if (!saved_args) {
    return 0;
  }

  struct event *e;
  e = bpf_ringbuf_reserve(&events, sizeof(*e), 0);
  if (!e) {
    bpf_map_delete_elem(&tmp_storage, &tid);
    return 0;
  }

  e->cgroup_id = bpf_get_current_cgroup_id();
  e->pid = pid;

  u64 uid_gid = bpf_get_current_uid_gid();
  e->uid = (u32)uid_gid;
  e->gid = (u32)(uid_gid >> 32);

  bpf_get_current_comm(&e->comm, sizeof(e->comm));

  // === ИСПРАВЛЕННОЕ ПОЛУЧЕНИЕ PPID ===
  // Вместо макроса BPF_CORE_READ используем стандартные функции чтения.

  struct task_struct *task = (struct task_struct *)bpf_get_current_task();
  struct task_struct *parent;

  // 1. Читаем указатель на родителя (task->real_parent)
  // Используем preserve_access_index для поддержки CO-RE (переносимости между
  // ядрами)
  bpf_probe_read_kernel(&parent, sizeof(parent), &task->real_parent);

  // 2. Читаем PID из структуры родителя (parent->tgid)
  bpf_probe_read_kernel(&e->ppid, sizeof(e->ppid), &parent->tgid);
  bpf_probe_read_kernel(&e->pcomm, sizeof(e->pcomm), &parent->comm);
  // ===================================

  e->dfd = saved_args->dfd;
  e->flags = saved_args->flags;
  bpf_probe_read_kernel(&e->filename, sizeof(e->filename),
                        saved_args->filename);
  e->ret = (int)ctx->ret;

  bpf_ringbuf_submit(e, 0);
  bpf_map_delete_elem(&tmp_storage, &tid);

  return 0;
}

char LICENSE[] SEC("license") = "GPL";
